use schemars::{
    generate::{SchemaGenerator, SchemaSettings},
    JsonSchema,
};
use serde_json::{Map, Value};
use sha2::{Digest, Sha256};

use crate::error::{Result, StructuredError};

/// Trait implemented by any type that can be used as a structured Gemini response.
pub trait GeminiStructured: JsonSchema {
    /// Produce a Gemini-compatible OpenAPI 3 schema.
    fn gemini_schema() -> Value {
        let settings = SchemaSettings::openapi3().with(|s| {
            // Inline subschemas to keep strict-mode compatibility.
            s.inline_subschemas = true;
            s.meta_schema = None;
        });

        let generator = SchemaGenerator::new(settings);
        let schema = generator.into_root_schema_for::<Self>();
        let mut value = serde_json::to_value(&schema).unwrap();

        clean_schema_for_gemini(&mut value);
        value
    }

    /// Stable hash for caching schemas and prompts.
    fn gemini_schema_hash() -> String {
        schema_hash(&Self::gemini_schema())
    }
}

impl<T: JsonSchema> GeminiStructured for T {}

/// Compile a JSON Schema validator for the given type.
pub fn compile_validator<T: GeminiStructured>() -> Result<jsonschema::Validator> {
    let schema = T::gemini_schema();
    let validation_schema = to_standard_json_schema(schema);
    jsonschema::validator_for(&validation_schema)
        .map_err(|e| StructuredError::Validation(format!("Failed to compile schema: {e}")))
}

/// Compute a stable hash for a schema or prompt fragment.
pub fn schema_hash(value: &Value) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.to_string());
    let digest = hasher.finalize();
    digest
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>()
}

/// Optional logical validator that types can implement to enforce domain rules
/// that JSON Schema cannot express.
///
/// All types get a default implementation that always returns `None` (valid).
/// To add custom validation, manually implement this trait for your type.
pub trait StructuredValidator {
    /// Return `Some(message)` when invalid, otherwise `None`.
    fn validate(&self) -> Option<String>;
}

/// Blanket implementation providing default "always valid" behavior for all types.
impl<T> StructuredValidator for T {
    fn validate(&self) -> Option<String> {
        None
    }
}

/// Trait for custom validation logic generated by `#[derive(GeminiValidated)]`.
///
/// This trait is separate from `StructuredValidator` to allow the derive macro
/// to work alongside the blanket implementation of `StructuredValidator`.
///
/// Types implementing this trait should also implement `StructuredValidator`
/// manually to integrate with the library's validation flow.
pub trait GeminiValidator {
    /// Perform custom validation. Returns `Some(error_message)` if invalid.
    fn gemini_validate(&self) -> Option<String>;
}

/// Recursively strip or normalize fields that Gemini strict schema mode does not support.
pub fn clean_schema_for_gemini(value: &mut Value) {
    let snapshot = value.clone();
    let mut stack = Vec::new();
    inline_refs(value, &snapshot, &mut stack);
    strip_unsupported(value);
}

fn inline_refs(value: &mut Value, root: &Value, stack: &mut Vec<String>) {
    match value {
        Value::Object(map) => {
            if let Some(Value::String(reference)) = map.get("$ref") {
                let reference = reference.clone();
                if stack.contains(&reference) {
                    *value = Value::Object(Map::new());
                    return;
                }
                if let Some(resolved) = resolve_pointer(root, &reference) {
                    stack.push(reference);
                    let mut resolved = resolved.clone();
                    inline_refs(&mut resolved, root, stack);
                    stack.pop();
                    *value = resolved;
                    return;
                }
                *value = Value::Object(Map::new());
                return;
            }

            for (_, v) in map.iter_mut() {
                inline_refs(v, root, stack);
            }
        }
        Value::Array(arr) => {
            for v in arr {
                inline_refs(v, root, stack);
            }
        }
        _ => {}
    }
}

fn resolve_pointer<'a>(root: &'a Value, reference: &str) -> Option<&'a Value> {
    let pointer = reference.strip_prefix('#').unwrap_or(reference);
    root.pointer(pointer)
}

fn strip_unsupported(value: &mut Value) {
    if let Value::Object(map) = value {
        // Keywords unsupported by Gemini strict mode that we should strip.
        // Note: 'title' is preserved to guide the model output. 'additionalProperties'
        // and OpenAPI definition blocks are stripped to satisfy the v1beta schema validator.
        let unsupported = [
            "$schema",
            "$ref",
            "additionalProperties",
            "components",
            "definitions",
            "$defs",
            "default",
            "examples",
            "pattern",
            "minLength",
            "maxLength",
            "minProperties",
            "maxProperties",
            "anyOf",
            "oneOf",
            "not",
            "if",
            "then",
            "else",
            "const",
            "allOf",
        ];

        for key in unsupported {
            map.remove(key);
        }

        for (key, v) in map.iter_mut() {
            // For properties/definitions maps, recurse into the values without
            // stripping the property keys themselves.
            if key == "properties" || key == "definitions" || key == "$defs" {
                if let Value::Object(sub_map) = v {
                    for (_, sub_schema) in sub_map.iter_mut() {
                        strip_unsupported(sub_schema);
                    }
                }
            } else {
                strip_unsupported(v);
            }
        }
    } else if let Value::Array(arr) = value {
        for v in arr {
            strip_unsupported(v);
        }
    }
}

/// Convert an OpenAPI-style schema (with nullable: true) to a standard JSON Schema
/// (with type: [T, "null"]) for compatibility with the jsonschema crate.
fn to_standard_json_schema(mut schema: Value) -> Value {
    if let Value::Object(ref mut map) = schema {
        // Handle nullable: true
        if let Some(Value::Bool(true)) = map.remove("nullable") {
            if let Some(type_val) = map.get_mut("type") {
                match type_val {
                    Value::String(s) => {
                        *type_val = serde_json::json!([s, "null"]);
                    }
                    Value::Array(arr) => {
                        let has_null = arr.iter().any(|v| v.as_str() == Some("null"));
                        if !has_null {
                            arr.push(Value::String("null".to_string()));
                        }
                    }
                    _ => {}
                }
            }
        }

        for val in map.values_mut() {
            let taken = std::mem::replace(val, Value::Null);
            *val = to_standard_json_schema(taken);
        }
    } else if let Value::Array(arr) = schema {
        let new_arr = arr.into_iter().map(to_standard_json_schema).collect();
        return Value::Array(new_arr);
    }
    schema
}

#[cfg(test)]
mod tests {
    use super::*;
    use schemars::JsonSchema;
    use serde_json::json;
    use std::collections::HashMap;

    #[derive(JsonSchema)]
    struct Contact {
        phone: Option<String>,
    }

    #[test]
    fn option_fields_keep_nullable_flag() {
        let contact = Contact {
            phone: Some("123".to_string()),
        };
        // Read the field to avoid dead-code warnings while keeping the shape realistic.
        assert_eq!(contact.phone.as_deref(), Some("123"));

        let schema = Contact::gemini_schema();
        let phone_schema = schema
            .get("properties")
            .and_then(|p| p.get("phone"))
            .expect("phone schema should exist");

        assert_eq!(phone_schema.get("type"), Some(&json!("string")));
        assert_eq!(phone_schema.get("nullable"), Some(&json!(true)));
    }

    #[test]
    fn to_standard_json_schema_handles_nullable() {
        let openapi_schema = json!({
            "type": "string",
            "nullable": true
        });

        let standard = to_standard_json_schema(openapi_schema);
        assert_eq!(standard.get("nullable"), None);
        let types = standard
            .get("type")
            .and_then(|t| t.as_array())
            .expect("type should be array");
        assert!(types.contains(&json!("string")));
        assert!(types.contains(&json!("null")));
    }

    #[derive(JsonSchema)]
    struct MapWrapper {
        map: HashMap<String, String>,
    }

    #[test]
    fn map_schemas_strip_additional_properties() {
        let schema = MapWrapper::gemini_schema();
        let map_schema = schema
            .get("properties")
            .and_then(|p| p.get("map"))
            .expect("map schema should exist");

        assert!(map_schema.get("additionalProperties").is_none());
    }

    #[derive(JsonSchema)]
    struct Node {
        value: String,
        child: Option<Box<Node>>,
    }

    #[test]
    fn recursive_schemas_inline_refs() {
        let schema = Node::gemini_schema();
        let schema_json = schema.to_string();

        assert!(!schema_json.contains("\"$ref\""));
        assert!(!schema_json.contains("\"components\""));
    }
}
