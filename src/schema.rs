use std::collections::HashSet;

use schemars::{
    generate::{SchemaGenerator, SchemaSettings},
    JsonSchema,
};
use serde_json::{json, Map, Value};
use sha2::{Digest, Sha256};

use crate::error::{Result, StructuredError};

/// Trait implemented by any type that can be used as a structured Gemini response.
pub trait GeminiStructured: JsonSchema {
    /// Produce a Gemini-compatible OpenAPI 3 schema.
    fn gemini_schema() -> Value {
        let settings = SchemaSettings::openapi3().with(|s| {
            // Inline subschemas to keep strict-mode compatibility.
            s.inline_subschemas = true;
            s.meta_schema = None;
        });

        let generator = SchemaGenerator::new(settings);
        let schema = generator.into_root_schema_for::<Self>();
        let mut value = serde_json::to_value(&schema).unwrap();

        clean_schema_for_gemini(&mut value);
        value
    }

    /// Stable hash for caching schemas and prompts.
    fn gemini_schema_hash() -> String {
        schema_hash(&Self::gemini_schema())
    }
}

impl<T: JsonSchema> GeminiStructured for T {}

/// Compile a JSON Schema validator for the given type.
pub fn compile_validator<T: GeminiStructured>() -> Result<jsonschema::Validator> {
    let schema = T::gemini_schema();
    let validation_schema = to_standard_json_schema(schema);
    jsonschema::validator_for(&validation_schema)
        .map_err(|e| StructuredError::Validation(format!("Failed to compile schema: {e}")))
}

/// Compute a stable hash for a schema or prompt fragment.
pub fn schema_hash(value: &Value) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.to_string());
    let digest = hasher.finalize();
    digest
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>()
}

/// Optional logical validator that types can implement to enforce domain rules
/// that JSON Schema cannot express.
///
/// All types get a default implementation that always returns `None` (valid).
/// To add custom validation, manually implement this trait for your type.
pub trait StructuredValidator {
    /// Return `Some(message)` when invalid, otherwise `None`.
    fn validate(&self) -> Option<String>;
}

/// Blanket implementation providing default "always valid" behavior for all types.
impl<T> StructuredValidator for T {
    fn validate(&self) -> Option<String> {
        None
    }
}

/// Trait for custom validation logic generated by `#[derive(GeminiValidated)]`.
///
/// This trait is separate from `StructuredValidator` to allow the derive macro
/// to work alongside the blanket implementation of `StructuredValidator`.
///
/// Types implementing this trait should also implement `StructuredValidator`
/// manually to integrate with the library's validation flow.
pub trait GeminiValidator {
    /// Perform custom validation. Returns `Some(error_message)` if invalid.
    fn gemini_validate(&self) -> Option<String>;
}

/// Recursively strip or normalize fields that Gemini strict schema mode does not support.
pub fn clean_schema_for_gemini(value: &mut Value) {
    let snapshot = value.clone();
    let mut stack = Vec::new();
    inline_refs(value, &snapshot, &mut stack);
    clean_schema_node(value);
}

fn inline_refs(value: &mut Value, root: &Value, stack: &mut Vec<String>) {
    match value {
        Value::Object(map) => {
            if let Some(Value::String(reference)) = map.get("$ref") {
                let reference = reference.clone();
                if stack.contains(&reference) {
                    *value = Value::Object(Map::new());
                    return;
                }
                if let Some(resolved) = resolve_pointer(root, &reference) {
                    stack.push(reference);
                    let mut resolved = resolved.clone();
                    inline_refs(&mut resolved, root, stack);
                    stack.pop();
                    *value = resolved;
                    return;
                }
                *value = Value::Object(Map::new());
                return;
            }

            for (_, v) in map.iter_mut() {
                inline_refs(v, root, stack);
            }
        }
        Value::Array(arr) => {
            for v in arr {
                inline_refs(v, root, stack);
            }
        }
        _ => {}
    }
}

fn resolve_pointer<'a>(root: &'a Value, reference: &str) -> Option<&'a Value> {
    let pointer = reference.strip_prefix('#').unwrap_or(reference);
    root.pointer(pointer)
}

/// Determines the JSON Schema type from the schema node.
fn get_schema_type(map: &Map<String, Value>) -> Option<&str> {
    map.get("type").and_then(|v| v.as_str())
}

/// Common tag field names used for internally-tagged enums
const TAG_FIELD_NAMES: &[&str] = &["type", "kind", "model", "variant", "tag"];

/// Merges enum values from a new variant into an existing tag field
fn merge_tag_field(existing: &mut Value, new_variant: &Value) {
    // Extract enum values from both existing and new
    let existing_enums = existing
        .as_object()
        .and_then(|obj| obj.get("enum"))
        .and_then(|e| e.as_array())
        .cloned()
        .unwrap_or_default();

    let new_enums = new_variant
        .as_object()
        .and_then(|obj| obj.get("enum"))
        .and_then(|e| e.as_array())
        .cloned()
        .unwrap_or_default();

    // Merge enum values, avoiding duplicates
    let mut merged: Vec<Value> = existing_enums;
    for val in new_enums {
        if !merged.contains(&val) {
            merged.push(val);
        }
    }

    // Update the existing field with merged enum
    if let Some(obj) = existing.as_object_mut() {
        if !merged.is_empty() {
            obj.insert("enum".to_string(), json!(merged));
        }
        // Merge descriptions if both have them
        if let (Some(existing_desc), Some(new_desc)) = (
            obj.get("description").and_then(|d| d.as_str()),
            new_variant
                .as_object()
                .and_then(|o| o.get("description"))
                .and_then(|d| d.as_str()),
        ) {
            if existing_desc != new_desc && !existing_desc.contains(new_desc) {
                obj.insert(
                    "description".to_string(),
                    json!(format!("{} | {}", existing_desc, new_desc)),
                );
            }
        }
    }
}

/// Merges multiple schema variants into a single permissive object schema.
/// This allows Gemini to understand enum types by flattening all variant properties
/// into a single schema with the tag field containing all possible values.
fn flatten_variants(parent: &mut Map<String, Value>, variants: Vec<Value>) {
    // Force type to object
    parent.insert("type".to_string(), json!("object"));

    // Initialize or get the properties map
    let parent_props = parent
        .entry("properties".to_string())
        .or_insert(json!({}))
        .as_object_mut();

    let Some(parent_props) = parent_props else {
        return;
    };

    // Track required fields across variants for intersection
    let mut common_required: Option<HashSet<String>> = None;

    // Collect all descriptions from variants for the parent
    let mut variant_descriptions: Vec<String> = Vec::new();

    for variant in variants {
        if let Value::Object(v_map) = variant {
            // Collect variant description
            if let Some(desc) = v_map.get("description").and_then(|d| d.as_str()) {
                variant_descriptions.push(desc.to_string());
            }

            // Merge properties from this variant
            if let Some(Value::Object(props)) = v_map.get("properties") {
                for (k, v) in props {
                    if !parent_props.contains_key(k) {
                        parent_props.insert(k.clone(), v.clone());
                    } else if TAG_FIELD_NAMES.contains(&k.as_str()) {
                        // Merge enum values for tag fields
                        merge_tag_field(parent_props.get_mut(k).unwrap(), v);
                    }
                }
            }

            // Intersect required fields (only keep fields required in ALL variants)
            if let Some(Value::Array(req_arr)) = v_map.get("required") {
                let variant_required: HashSet<String> = req_arr
                    .iter()
                    .filter_map(|v| v.as_str().map(String::from))
                    .collect();

                common_required = Some(match common_required.take() {
                    Some(existing) => existing.intersection(&variant_required).cloned().collect(),
                    None => variant_required,
                });
            }
        }
    }

    // Set the intersected required fields
    if let Some(required) = common_required {
        if !required.is_empty() {
            let required_vec: Vec<Value> = required.into_iter().map(Value::String).collect();
            parent.insert("required".to_string(), json!(required_vec));
        }
    }

    // Add combined description if we collected any
    if !variant_descriptions.is_empty() && !parent.contains_key("description") {
        parent.insert(
            "description".to_string(),
            json!(format!(
                "One of the following variants: {}",
                variant_descriptions.join(" | ")
            )),
        );
    }

    // Recursively clean the merged properties
    if let Some(Value::Object(props)) = parent.get_mut("properties") {
        for sub_schema in props.values_mut() {
            clean_schema_node(sub_schema);
        }
    }
}

/// Clean a schema node based on Gemini's supported properties per type.
///
/// Gemini supports the following JSON Schema properties:
/// - Common: type, title, description, nullable, enum
/// - For objects: properties, required, additionalProperties
/// - For strings: enum, format
/// - For numbers/integers: enum, minimum, maximum
/// - For arrays: items, prefixItems, minItems, maxItems
fn clean_schema_node(value: &mut Value) {
    if let Value::Object(map) = value {
        // Properties that are never supported by Gemini
        // Note: "const" is handled manually below during oneOf/anyOf processing
        let always_unsupported = [
            "$schema",
            "$ref",
            "components",
            "definitions",
            "$defs",
            "default",
            "examples",
            "not",
            "if",
            "then",
            "else",
            "allOf",
        ];

        for key in always_unsupported {
            map.remove(key);
        }

        // Handle oneOf/anyOf intelligently based on variant types
        if let Some(Value::Array(variants)) = map.remove("oneOf").or_else(|| map.remove("anyOf")) {
            // Check if this is a simple string enum (e.g., Rust unit variants)
            // Schemars generates these as: { "type": "string", "const": "Value" }
            let is_pure_string_enum = variants.iter().all(|v| {
                v.get("type").and_then(|t| t.as_str()) == Some("string")
                    && (v.get("const").is_some() || v.get("enum").is_some())
            });

            if is_pure_string_enum {
                // CASE 1: Pure String Enum (e.g., AccountType)
                // Convert to { "type": "string", "enum": ["A", "B"] }
                let mut enum_values = Vec::new();
                for v in variants {
                    if let Some(c) = v.get("const") {
                        enum_values.push(c.clone());
                    } else if let Some(Value::Array(enums)) = v.get("enum") {
                        enum_values.extend(enums.clone());
                    }
                }
                // Deduplicate
                enum_values.sort_by_key(|a| a.to_string());
                enum_values.dedup();

                map.insert("type".to_string(), json!("string"));
                map.insert("enum".to_string(), Value::Array(enum_values));
            } else {
                // Check for mixed types (Strings AND Objects)
                // This happens in Rust enums with both Unit and Struct variants
                let has_objects = variants
                    .iter()
                    .any(|v| v.get("type").and_then(|t| t.as_str()) == Some("object"));
                let has_strings = variants
                    .iter()
                    .any(|v| v.get("type").and_then(|t| t.as_str()) == Some("string"));

                if has_objects && has_strings {
                    // CASE 2: Mixed Enum (e.g., SeasonalityProfileId with both "Flat" and { "Custom": ... })
                    // We cannot flatten this into a single object.
                    // Preserve as `anyOf` and let Gemini handle it (supported in newer models).
                    let mut cleaned_variants: Vec<Value> = Vec::new();
                    for mut variant in variants {
                        clean_schema_node(&mut variant);
                        cleaned_variants.push(variant);
                    }
                    map.insert("anyOf".to_string(), Value::Array(cleaned_variants));

                    // Remove specific type constraints from the parent if they exist
                    // because the child can be either string OR object.
                    map.remove("type");
                } else {
                    // CASE 3: Complex Object Union
                    // Proceed with existing flattening logic
                    flatten_variants(map, variants);
                }
            }
        }

        // Remove const at the top level (we've already extracted values from variants above)
        map.remove("const");

        // Get the type to determine which properties to keep
        let schema_type = get_schema_type(map).map(|s| s.to_string());

        // Properties only valid for specific types
        match schema_type.as_deref() {
            Some("object") => {
                // Object types support: properties, required, additionalProperties
                // Remove string-specific properties
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("format");
                // Remove array-specific properties
                map.remove("items");
                map.remove("prefixItems");
                map.remove("minItems");
                map.remove("maxItems");
                // Remove number-specific properties
                map.remove("minimum");
                map.remove("maximum");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
            Some("array") => {
                // Array types support: items, prefixItems, minItems, maxItems
                // Remove object-specific properties
                map.remove("properties");
                map.remove("required");
                map.remove("additionalProperties");
                // Remove string-specific properties
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("format");
                // Remove number-specific properties
                map.remove("minimum");
                map.remove("maximum");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
            Some("string") => {
                // String types support: enum, format
                // Remove object-specific properties
                map.remove("properties");
                map.remove("required");
                map.remove("additionalProperties");
                // Remove array-specific properties
                map.remove("items");
                map.remove("prefixItems");
                map.remove("minItems");
                map.remove("maxItems");
                // Remove number-specific properties
                map.remove("minimum");
                map.remove("maximum");
                // Remove unsupported string validation (Gemini doesn't support these)
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
            Some("number") | Some("integer") => {
                // Number types support: enum, minimum, maximum
                // Remove object-specific properties
                map.remove("properties");
                map.remove("required");
                map.remove("additionalProperties");
                // Remove array-specific properties
                map.remove("items");
                map.remove("prefixItems");
                map.remove("minItems");
                map.remove("maxItems");
                // Remove string-specific properties
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("format");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
            Some("boolean") | Some("null") => {
                // Boolean/null types don't have type-specific properties
                map.remove("properties");
                map.remove("required");
                map.remove("additionalProperties");
                map.remove("items");
                map.remove("prefixItems");
                map.remove("minItems");
                map.remove("maxItems");
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("format");
                map.remove("minimum");
                map.remove("maximum");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
            _ => {
                // Unknown or missing type - be conservative and remove most things
                // but keep additionalProperties if it looks like an object schema
                if !map.contains_key("properties") {
                    map.remove("additionalProperties");
                }
                map.remove("pattern");
                map.remove("minLength");
                map.remove("maxLength");
                map.remove("minProperties");
                map.remove("maxProperties");
            }
        }

        // Recursively clean nested schemas
        for (key, v) in map.iter_mut() {
            if key == "properties" {
                if let Value::Object(sub_map) = v {
                    for sub_schema in sub_map.values_mut() {
                        clean_schema_node(sub_schema);
                    }
                }
            } else if key == "items" || key == "additionalProperties" {
                // These can be schemas themselves
                clean_schema_node(v);
            } else if key == "prefixItems" {
                if let Value::Array(arr) = v {
                    for item in arr {
                        clean_schema_node(item);
                    }
                }
            } else if key != "required" && key != "enum" && key != "type" {
                // Recurse into other nested values (but not simple property values)
                clean_schema_node(v);
            }
        }
    } else if let Value::Array(arr) = value {
        for v in arr {
            clean_schema_node(v);
        }
    }
}

/// Convert an OpenAPI-style schema (with nullable: true) to a standard JSON Schema
/// (with type: [T, "null"]) for compatibility with the jsonschema crate.
fn to_standard_json_schema(mut schema: Value) -> Value {
    if let Value::Object(ref mut map) = schema {
        // Handle nullable: true
        if let Some(Value::Bool(true)) = map.remove("nullable") {
            if let Some(type_val) = map.get_mut("type") {
                match type_val {
                    Value::String(s) => {
                        *type_val = serde_json::json!([s, "null"]);
                    }
                    Value::Array(arr) => {
                        let has_null = arr.iter().any(|v| v.as_str() == Some("null"));
                        if !has_null {
                            arr.push(Value::String("null".to_string()));
                        }
                    }
                    _ => {}
                }
            }
        }

        for val in map.values_mut() {
            let taken = std::mem::replace(val, Value::Null);
            *val = to_standard_json_schema(taken);
        }
    } else if let Value::Array(arr) = schema {
        let new_arr = arr.into_iter().map(to_standard_json_schema).collect();
        return Value::Array(new_arr);
    }
    schema
}

#[cfg(test)]
mod tests {
    use super::*;
    use schemars::JsonSchema;
    use serde_json::json;
    use std::collections::HashMap;

    #[derive(JsonSchema)]
    struct Contact {
        phone: Option<String>,
    }

    #[test]
    fn option_fields_keep_nullable_flag() {
        let contact = Contact {
            phone: Some("123".to_string()),
        };
        // Read the field to avoid dead-code warnings while keeping the shape realistic.
        assert_eq!(contact.phone.as_deref(), Some("123"));

        let schema = Contact::gemini_schema();
        let phone_schema = schema
            .get("properties")
            .and_then(|p| p.get("phone"))
            .expect("phone schema should exist");

        assert_eq!(phone_schema.get("type"), Some(&json!("string")));
        assert_eq!(phone_schema.get("nullable"), Some(&json!(true)));
    }

    #[test]
    fn to_standard_json_schema_handles_nullable() {
        let openapi_schema = json!({
            "type": "string",
            "nullable": true
        });

        let standard = to_standard_json_schema(openapi_schema);
        assert_eq!(standard.get("nullable"), None);
        let types = standard
            .get("type")
            .and_then(|t| t.as_array())
            .expect("type should be array");
        assert!(types.contains(&json!("string")));
        assert!(types.contains(&json!("null")));
    }

    #[derive(JsonSchema)]
    struct MapWrapper {
        map: HashMap<String, String>,
    }

    #[test]
    fn map_schemas_keep_additional_properties_for_objects() {
        let schema = MapWrapper::gemini_schema();
        let map_schema = schema
            .get("properties")
            .and_then(|p| p.get("map"))
            .expect("map schema should exist");

        // additionalProperties should be preserved for object types
        // as Gemini supports it per API reference
        assert_eq!(map_schema.get("type"), Some(&json!("object")));
        // additionalProperties may or may not be present depending on schemars output
    }

    #[derive(JsonSchema)]
    struct Node {
        value: String,
        child: Option<Box<Node>>,
    }

    #[test]
    fn recursive_schemas_inline_refs() {
        let schema = Node::gemini_schema();
        let schema_json = schema.to_string();

        assert!(!schema_json.contains("\"$ref\""));
        assert!(!schema_json.contains("\"components\""));
    }

    // Pure string enum - should be converted to { "type": "string", "enum": [...] }
    #[derive(JsonSchema)]
    enum AccountType {
        Revenue,
        CostOfSales,
        Expense,
        Asset,
        Liability,
    }

    #[test]
    fn pure_string_enum_converts_to_string_with_enum() {
        let schema = AccountType::gemini_schema();

        // Should be type: "string" with enum values
        assert_eq!(schema.get("type"), Some(&json!("string")));

        let enum_values = schema
            .get("enum")
            .and_then(|e| e.as_array())
            .expect("enum should exist and be an array");

        // All variants should be present
        assert!(enum_values.contains(&json!("Revenue")));
        assert!(enum_values.contains(&json!("CostOfSales")));
        assert!(enum_values.contains(&json!("Expense")));
        assert!(enum_values.contains(&json!("Asset")));
        assert!(enum_values.contains(&json!("Liability")));

        // Should NOT have object properties (the old broken behavior)
        assert!(schema.get("properties").is_none());
        assert!(schema.get("oneOf").is_none());
        assert!(schema.get("anyOf").is_none());
    }

    // Mixed enum with both unit variants and struct variants
    #[derive(JsonSchema)]
    enum SeasonalityProfileId {
        Flat,
        Custom { values: Vec<f64> },
    }

    #[test]
    fn mixed_enum_preserves_anyof() {
        let schema = SeasonalityProfileId::gemini_schema();

        // Should have anyOf preserved (not flattened)
        let any_of = schema
            .get("anyOf")
            .and_then(|a| a.as_array())
            .expect("anyOf should exist and be an array");

        // Should have 2 variants
        assert_eq!(any_of.len(), 2);

        // Check that we have both string and object variants
        let has_string_variant = any_of
            .iter()
            .any(|v| v.get("type").and_then(|t| t.as_str()) == Some("string"));
        let has_object_variant = any_of
            .iter()
            .any(|v| v.get("type").and_then(|t| t.as_str()) == Some("object"));

        assert!(has_string_variant, "Should have a string variant");
        assert!(has_object_variant, "Should have an object variant");

        // Parent should NOT have type (since it could be string or object)
        assert!(schema.get("type").is_none());
    }

    // Complex object enum - should still flatten
    #[derive(JsonSchema)]
    enum Message {
        Request { id: u32, payload: String },
        Response { id: u32, result: String },
    }

    #[test]
    fn complex_object_enum_flattens() {
        let schema = Message::gemini_schema();

        // Should be flattened to an object
        assert_eq!(schema.get("type"), Some(&json!("object")));

        // Schemars uses externally-tagged format by default:
        // Each variant name becomes a property with its fields as nested object
        let properties = schema
            .get("properties")
            .and_then(|p| p.as_object())
            .expect("properties should exist");

        // Variant names should be properties
        assert!(properties.contains_key("Request"));
        assert!(properties.contains_key("Response"));

        // Each variant should have its nested properties
        let request_props = properties
            .get("Request")
            .and_then(|r| r.get("properties"))
            .and_then(|p| p.as_object())
            .expect("Request properties should exist");
        assert!(request_props.contains_key("id"));
        assert!(request_props.contains_key("payload"));

        // Should NOT have anyOf (should be flattened)
        assert!(schema.get("anyOf").is_none());
        assert!(schema.get("oneOf").is_none());
    }
}
