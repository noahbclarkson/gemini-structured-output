use schemars::{
    generate::{SchemaGenerator, SchemaSettings},
    JsonSchema,
};
use serde_json::Value;
use sha2::{Digest, Sha256};

use crate::error::{Result, StructuredError};

/// Trait implemented by any type that can be used as a structured Gemini response.
pub trait GeminiStructured: JsonSchema {
    /// Produce a Gemini-compatible OpenAPI 3 schema.
    fn gemini_schema() -> Value {
        let settings = SchemaSettings::openapi3().with(|s| {
            // Inline subschemas to keep strict-mode compatibility.
            s.inline_subschemas = true;
            s.meta_schema = None;
        });

        let generator = SchemaGenerator::new(settings);
        let schema = generator.into_root_schema_for::<Self>();
        let mut value = serde_json::to_value(&schema).unwrap();

        clean_schema_for_gemini(&mut value);
        value
    }

    /// Stable hash for caching schemas and prompts.
    fn gemini_schema_hash() -> String {
        schema_hash(&Self::gemini_schema())
    }
}

impl<T: JsonSchema> GeminiStructured for T {}

/// Compile a JSON Schema validator for the given type.
pub fn compile_validator<T: GeminiStructured>() -> Result<jsonschema::Validator> {
    let schema = T::gemini_schema();
    let validation_schema = to_standard_json_schema(schema);
    jsonschema::validator_for(&validation_schema)
        .map_err(|e| StructuredError::Validation(format!("Failed to compile schema: {e}")))
}

/// Compute a stable hash for a schema or prompt fragment.
pub fn schema_hash(value: &Value) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.to_string());
    let digest = hasher.finalize();
    digest
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>()
}

/// Optional logical validator that types can implement to enforce domain rules
/// that JSON Schema cannot express.
///
/// All types get a default implementation that always returns `None` (valid).
/// To add custom validation, manually implement this trait for your type.
pub trait StructuredValidator {
    /// Return `Some(message)` when invalid, otherwise `None`.
    fn validate(&self) -> Option<String>;
}

/// Blanket implementation providing default "always valid" behavior for all types.
impl<T> StructuredValidator for T {
    fn validate(&self) -> Option<String> {
        None
    }
}

/// Trait for custom validation logic generated by `#[derive(GeminiValidated)]`.
///
/// This trait is separate from `StructuredValidator` to allow the derive macro
/// to work alongside the blanket implementation of `StructuredValidator`.
///
/// Types implementing this trait should also implement `StructuredValidator`
/// manually to integrate with the library's validation flow.
pub trait GeminiValidator {
    /// Perform custom validation. Returns `Some(error_message)` if invalid.
    fn gemini_validate(&self) -> Option<String>;
}

/// Recursively strip or normalize fields that Gemini strict schema mode does not support.
pub fn clean_schema_for_gemini(value: &mut Value) {
    if let Value::Object(map) = value {
        // Keywords unsupported by Gemini strict mode that we should strip.
        // Note: 'title' and 'additionalProperties' are supported and must be preserved
        // because they can be legitimate field names in user schemas.
        let unsupported = [
            "$schema",
            "default",
            "examples",
            "pattern",
            "minLength",
            "maxLength",
            "minProperties",
            "maxProperties",
            "anyOf",
            "oneOf",
            "not",
            "if",
            "then",
            "else",
            "const",
        ];

        for key in unsupported {
            map.remove(key);
        }

        for (key, v) in map.iter_mut() {
            // For properties/definitions maps, recurse into the values without
            // stripping the property keys themselves.
            if key == "properties" || key == "definitions" || key == "$defs" {
                if let Value::Object(sub_map) = v {
                    for (_, sub_schema) in sub_map.iter_mut() {
                        clean_schema_for_gemini(sub_schema);
                    }
                }
            } else {
                clean_schema_for_gemini(v);
            }
        }
    } else if let Value::Array(arr) = value {
        for v in arr {
            clean_schema_for_gemini(v);
        }
    }
}

/// Convert an OpenAPI-style schema (with nullable: true) to a standard JSON Schema
/// (with type: [T, "null"]) for compatibility with the jsonschema crate.
fn to_standard_json_schema(mut schema: Value) -> Value {
    if let Value::Object(ref mut map) = schema {
        // Handle nullable: true
        if let Some(Value::Bool(true)) = map.remove("nullable") {
            if let Some(type_val) = map.get_mut("type") {
                match type_val {
                    Value::String(s) => {
                        *type_val = serde_json::json!([s, "null"]);
                    }
                    Value::Array(arr) => {
                        let has_null = arr.iter().any(|v| v.as_str() == Some("null"));
                        if !has_null {
                            arr.push(Value::String("null".to_string()));
                        }
                    }
                    _ => {}
                }
            }
        }

        for val in map.values_mut() {
            let taken = std::mem::replace(val, Value::Null);
            *val = to_standard_json_schema(taken);
        }
    } else if let Value::Array(arr) = schema {
        let new_arr = arr.into_iter().map(to_standard_json_schema).collect();
        return Value::Array(new_arr);
    }
    schema
}

#[cfg(test)]
mod tests {
    use super::*;
    use schemars::JsonSchema;
    use serde_json::json;

    #[derive(JsonSchema)]
    struct Contact {
        phone: Option<String>,
    }

    #[test]
    fn option_fields_keep_nullable_flag() {
        let contact = Contact {
            phone: Some("123".to_string()),
        };
        // Read the field to avoid dead-code warnings while keeping the shape realistic.
        assert_eq!(contact.phone.as_deref(), Some("123"));

        let schema = Contact::gemini_schema();
        let phone_schema = schema
            .get("properties")
            .and_then(|p| p.get("phone"))
            .expect("phone schema should exist");

        assert_eq!(phone_schema.get("type"), Some(&json!("string")));
        assert_eq!(phone_schema.get("nullable"), Some(&json!(true)));
    }

    #[test]
    fn to_standard_json_schema_handles_nullable() {
        let openapi_schema = json!({
            "type": "string",
            "nullable": true
        });

        let standard = to_standard_json_schema(openapi_schema);
        assert_eq!(standard.get("nullable"), None);
        let types = standard
            .get("type")
            .and_then(|t| t.as_array())
            .expect("type should be array");
        assert!(types.contains(&json!("string")));
        assert!(types.contains(&json!("null")));
    }
}
