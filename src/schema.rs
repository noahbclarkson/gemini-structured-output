use schemars::{
    generate::{SchemaGenerator, SchemaSettings},
    JsonSchema,
};
use serde_json::{json, Map, Value};
use sha2::{Digest, Sha256};
use tracing::{debug, warn};

use crate::error::{Result, StructuredError};

/// Trait implemented by any type that can be used as a structured Gemini response.
pub trait GeminiStructured: JsonSchema {
    /// Produce a Gemini-compatible JSON Schema.
    fn gemini_schema() -> Value {
        let settings = SchemaSettings::draft2020_12().with(|s| {
            s.meta_schema = None;
        });

        let generator = SchemaGenerator::new(settings);
        let schema = generator.into_root_schema_for::<Self>();
        serde_json::to_value(&schema).unwrap()
    }

    /// Stable hash for caching schemas and prompts.
    fn gemini_schema_hash() -> String {
        schema_hash(&Self::gemini_schema())
    }
}

impl<T: JsonSchema> GeminiStructured for T {}

/// Compile a JSON Schema validator for the given type.
pub fn compile_validator<T: GeminiStructured>() -> Result<jsonschema::Validator> {
    let schema = T::gemini_schema();
    let validation_schema = to_standard_json_schema(schema);
    jsonschema::validator_for(&validation_schema)
        .map_err(|e| StructuredError::Validation(format!("Failed to compile schema: {e}")))
}

/// Compute a stable hash for a schema or prompt fragment.
pub fn schema_hash(value: &Value) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.to_string());
    let digest = hasher.finalize();
    digest
        .iter()
        .map(|b| format!("{:02x}", b))
        .collect::<String>()
}

/// Optional logical validator that types can implement to enforce domain rules
/// that JSON Schema cannot express.
///
/// All types get a default implementation that always returns `None` (valid).
/// To add custom validation, manually implement this trait for your type.
pub trait StructuredValidator {
    /// Return `Some(message)` when invalid, otherwise `None`.
    fn validate(&self) -> Option<String>;
}

/// Blanket implementation providing default "always valid" behavior for all types.
impl<T> StructuredValidator for T {
    fn validate(&self) -> Option<String> {
        None
    }
}

/// Trait for custom validation logic generated by `#[derive(GeminiValidated)]`.
///
/// This trait is separate from `StructuredValidator` to allow the derive macro
/// to work alongside the blanket implementation of `StructuredValidator`.
///
/// Types implementing this trait should also implement `StructuredValidator`
/// manually to integrate with the library's validation flow.
pub trait GeminiValidator {
    /// Perform custom validation. Returns `Some(error_message)` if invalid.
    fn gemini_validate(&self) -> Option<String>;
}

/// Recursively strip fields that Gemini strict schema mode does not support.
pub fn clean_schema_for_gemini(value: &mut Value) {
    match value {
        Value::Object(map) => {
            let unsupported = [
                "$schema",
                "default",
                "examples",
                "example",
                "title",
                "readOnly",
                "writeOnly",
                "deprecated",
                "pattern",
                "minLength",
                "maxLength",
                "minProperties",
                "maxProperties",
                "if",
                "then",
                "else",
                "not",
                "const",
            ];

            for key in unsupported {
                map.remove(key);
            }

            for v in map.values_mut() {
                clean_schema_for_gemini(v);
            }
        }
        Value::Array(arr) => {
            for v in arr {
                clean_schema_for_gemini(v);
            }
        }
        _ => {}
    }
}

/// Strip x-* custom fields from a schema before sending to Gemini.
/// These fields are used internally but Gemini doesn't accept them.
pub fn strip_x_fields(value: &mut Value) {
    match value {
        Value::Object(map) => {
            // Remove all keys starting with "x-"
            map.retain(|k, _| !k.starts_with("x-"));

            // Recursively process remaining values
            for v in map.values_mut() {
                strip_x_fields(v);
            }
        }
        Value::Array(arr) => {
            for item in arr {
                strip_x_fields(item);
            }
        }
        _ => {}
    }
}

/// Returns the max logical nesting depth of the data structure described by the schema.
/// This ignores JSON Schema syntax nesting and counts actual data layers.
pub fn schema_depth(value: &Value) -> usize {
    fn walk(value: &Value, current_depth: usize) -> usize {
        match value {
            Value::Object(map) => {
                let mut max_child_depth = current_depth;

                if let Some(props) = map.get("properties").and_then(|v| v.as_object()) {
                    for sub_schema in props.values() {
                        max_child_depth =
                            max_child_depth.max(walk(sub_schema, current_depth + 1));
                    }
                }

                if let Some(items) = map.get("items") {
                    max_child_depth = max_child_depth.max(walk(items, current_depth + 1));
                }

                if let Some(add_props) = map.get("additionalProperties") {
                    if add_props.is_object() {
                        max_child_depth = max_child_depth.max(walk(add_props, current_depth + 1));
                    }
                }

                for key in ["anyOf", "oneOf"] {
                    if let Some(variants) = map.get(key).and_then(|v| v.as_array()) {
                        for variant in variants {
                            max_child_depth = max_child_depth.max(walk(variant, current_depth));
                        }
                    }
                }

                if let Some(defs) = map.get("$defs").and_then(|v| v.as_object()) {
                    for def in defs.values() {
                        max_child_depth = max_child_depth.max(walk(def, 1));
                    }
                }

                max_child_depth
            }
            _ => current_depth,
        }
    }

    walk(value, 0)
}

/// Emit a warning if a schema exceeds the suggested nesting depth.
pub fn warn_if_schema_too_deep(schema: &Value, max_depth: usize) {
    let depth = schema_depth(schema);
    if depth >= max_depth {
        warn!(schema.depth = depth, schema.depth.max = max_depth, "Schema nesting depth is high; Gemini strict mode may reject deeply nested schemas");
    }
}

/// Conservative nesting depth threshold for Gemini strict schema mode.
/// Updated based on logical depth calculation.
pub const STRICT_SCHEMA_DEPTH_LIMIT: usize = 5;

/// Recursively remove object keys where the value is null.
pub fn prune_null_fields(value: &mut Value) {
    match value {
        Value::Object(map) => {
            map.retain(|_, v| !v.is_null());
            for v in map.values_mut() {
                prune_null_fields(v);
            }
        }
        Value::Array(arr) => {
            for v in arr {
                prune_null_fields(v);
            }
        }
        _ => {}
    }
}

const TAG_FIELD_NAMES: &[&str] = &["type", "kind", "model", "variant", "tag"];

/// Recursively attempts to recover internally tagged enums where the LLM
/// output a string literal instead of the wrapper object.
pub fn recover_internally_tagged_enums(value: &mut Value, schema: &Value) {
    recover_internally_tagged_enums_with_root(value, schema, schema);
}

fn recover_internally_tagged_enums_with_root(value: &mut Value, schema: &Value, root: &Value) {
    let schema = deref_schema(schema, root);

    match value {
        Value::Array(arr) => {
            if let Some(items_schema) = schema.get("items") {
                for item in arr {
                    recover_internally_tagged_enums_with_root(item, items_schema, root);
                }
            } else if let Some(prefix_items) = schema.get("prefixItems").and_then(|v| v.as_array())
            {
                for (i, item) in arr.iter_mut().enumerate() {
                    if let Some(sub_schema) = prefix_items.get(i) {
                        recover_internally_tagged_enums_with_root(item, sub_schema, root);
                    }
                }
            }
        }
        Value::Object(map) => {
            if let Some(props) = schema.get("properties").and_then(|v| v.as_object()) {
                let additional = schema.get("additionalProperties");
                for (k, v) in map.iter_mut() {
                    if let Some(sub_schema) = props.get(k) {
                        recover_internally_tagged_enums_with_root(v, sub_schema, root);
                    } else if let Some(additional) = additional {
                        recover_internally_tagged_enums_with_root(v, additional, root);
                    }
                }
                return;
            }

            if let Some(variants) = schema
                .get("anyOf")
                .or_else(|| schema.get("oneOf"))
                .and_then(|v| v.as_array())
            {
                if let Some(variant) = select_variant_for_object(map, variants) {
                    if let Some(props) = variant.get("properties").and_then(|p| p.as_object()) {
                        for (k, v) in map.iter_mut() {
                            if let Some(sub_schema) = props.get(k) {
                                recover_internally_tagged_enums_with_root(v, sub_schema, root);
                            }
                        }
                    }
                } else {
                    for variant in variants {
                        if let Some(props) = variant.get("properties").and_then(|p| p.as_object()) {
                            for (k, v) in map.iter_mut() {
                                if let Some(sub_schema) = props.get(k) {
                                    recover_internally_tagged_enums_with_root(v, sub_schema, root);
                                }
                            }
                        }
                    }
                }
            } else if let Some(additional) = schema.get("additionalProperties") {
                for v in map.values_mut() {
                    recover_internally_tagged_enums_with_root(v, additional, root);
                }
            }
        }
        Value::String(_) => {
            if recover_string_for_schema(value, schema) {
                return;
            }

            if let Some(variants) = schema
                .get("anyOf")
                .or_else(|| schema.get("oneOf"))
                .and_then(|v| v.as_array())
            {
                for variant in variants {
                    if recover_string_for_schema(value, variant) {
                        return;
                    }
                }
            }
        }
        _ => {}
    }
}

/// Coerce enum string values to the closest schema-defined value.
pub fn coerce_enum_strings(value: &mut Value, schema: &Value) {
    coerce_enum_strings_with_root(value, schema, schema, "$");
}

fn coerce_enum_strings_with_root(
    value: &mut Value,
    schema: &Value,
    root: &Value,
    path: &str,
) {
    let schema = deref_schema(schema, root);

    match value {
        Value::Array(arr) => {
            if let Some(items_schema) = schema.get("items") {
                for (idx, item) in arr.iter_mut().enumerate() {
                    let next_path = format!("{path}[{idx}]");
                    coerce_enum_strings_with_root(item, items_schema, root, &next_path);
                }
            } else if let Some(prefix_items) = schema.get("prefixItems").and_then(|v| v.as_array())
            {
                for (idx, item) in arr.iter_mut().enumerate() {
                    if let Some(sub_schema) = prefix_items.get(idx) {
                        let next_path = format!("{path}[{idx}]");
                        coerce_enum_strings_with_root(item, sub_schema, root, &next_path);
                    }
                }
            }
        }
        Value::Object(map) => {
            if let Some(props) = schema.get("properties").and_then(|v| v.as_object()) {
                let additional = schema.get("additionalProperties");
                for (k, v) in map.iter_mut() {
                    if let Some(sub_schema) = props.get(k) {
                        let next_path = format!("{path}.{k}");
                        coerce_enum_strings_with_root(v, sub_schema, root, &next_path);
                    } else if let Some(additional) = additional {
                        let next_path = format!("{path}.{k}");
                        coerce_enum_strings_with_root(v, additional, root, &next_path);
                    }
                }
                return;
            }

            if let Some(variants) = schema
                .get("anyOf")
                .or_else(|| schema.get("oneOf"))
                .and_then(|v| v.as_array())
            {
                if let Some(variant) = select_variant_for_object(map, variants) {
                    coerce_enum_strings_with_root(value, variant, root, path);
                } else {
                    for variant in variants {
                        coerce_enum_strings_with_root(value, variant, root, path);
                    }
                }
            } else if let Some(additional) = schema.get("additionalProperties") {
                for (k, v) in map.iter_mut() {
                    let next_path = format!("{path}.{k}");
                    coerce_enum_strings_with_root(v, additional, root, &next_path);
                }
            }
        }
        Value::String(s) => {
            let current = s.clone();
            if let Some(coerced) = coerce_string_enum_value(&current, schema) {
                if coerced.as_str() != Some(current.as_str()) {
                    debug!(
                        value.path = path,
                        value.from = %current,
                        value.to = %coerced,
                        "Coerced enum string to schema value"
                    );
                    *value = coerced;
                    return;
                }
            }

            if let Some(variants) = schema
                .get("anyOf")
                .or_else(|| schema.get("oneOf"))
                .and_then(|v| v.as_array())
            {
                for variant in variants {
                    if let Some(coerced) = coerce_string_enum_value(&current, variant) {
                        if coerced.as_str() != Some(current.as_str()) {
                            debug!(
                                value.path = path,
                                value.from = %current,
                                value.to = %coerced,
                                "Coerced enum string to schema value"
                            );
                            *value = coerced;
                            return;
                        }
                    }
                }
            }
        }
        _ => {}
    }
}

fn coerce_string_enum_value(input: &str, schema: &Value) -> Option<Value> {
    let candidates = enum_candidates(schema);
    if candidates.is_empty() {
        return None;
    }

    let input_norm = normalize_tag(input);
    let mut best: Option<(usize, String)> = None;

    for candidate in candidates {
        if input == candidate {
            return Some(Value::String(candidate));
        }

        let cand_norm = normalize_tag(&candidate);
        if input_norm == cand_norm {
            return Some(Value::String(candidate));
        }

        if input_norm.starts_with(&cand_norm) && cand_norm.len() >= 3 {
            return Some(Value::String(candidate));
        }
        if cand_norm.starts_with(&input_norm) && input_norm.len() >= 3 {
            return Some(Value::String(candidate));
        }

        let prefix_len = common_prefix_len(&input_norm, &cand_norm);
        if prefix_len >= 3 {
            let dist = levenshtein(&input_norm, &cand_norm);
            let max_len = input_norm.len().max(cand_norm.len());
            let threshold = (max_len / 2).clamp(2, 8);
            if dist <= threshold
                && best.as_ref().is_none_or(|(best_dist, _)| dist < *best_dist) {
                    best = Some((dist, candidate));
                }
        }
    }

    best.map(|(_, candidate)| Value::String(candidate))
}

fn enum_candidates(schema: &Value) -> Vec<String> {
    let mut values = Vec::new();

    if let Some(Value::String(const_val)) = schema.get("const") {
        values.push(const_val.clone());
    }

    if let Some(Value::Array(enums)) = schema.get("enum") {
        for v in enums {
            if let Some(s) = v.as_str() {
                values.push(s.to_string());
            }
        }
    }

    values
}

fn deref_schema<'a>(schema: &'a Value, root: &'a Value) -> &'a Value {
    if let Some(reference) = schema.get("$ref").and_then(|v| v.as_str()) {
        if let Some(resolved) = resolve_pointer(root, reference) {
            return resolved;
        }
    }
    schema
}

fn resolve_pointer<'a>(root: &'a Value, reference: &str) -> Option<&'a Value> {
    let pointer = reference.strip_prefix('#').unwrap_or(reference);
    root.pointer(pointer)
}

fn recover_string_for_schema(value: &mut Value, schema: &Value) -> bool {
    let input = match value.as_str() {
        Some(s) => s.to_string(),
        None => return false,
    };

    if let Some((tag_field, tag_value)) = find_tag_field(schema, &input) {
        debug!(
            tag_field = %tag_field,
            tag_value = %tag_value,
            "Recovering internally tagged enum from string"
        );
        *value = json!({ tag_field: tag_value });
        return true;
    }

    false
}

fn find_tag_field(schema: &Value, input: &str) -> Option<(String, Value)> {
    let props = schema.get("properties")?.as_object()?;
    let required = schema.get("required").and_then(|v| v.as_array());

    for (prop_name, prop_schema) in props {
        let matched = schema_matches_string_value(prop_schema, input)?;
        let is_required = required
            .map(|req| req.iter().any(|v| v.as_str() == Some(prop_name)))
            .unwrap_or(false);
        let is_tag_name = TAG_FIELD_NAMES.contains(&prop_name.as_str());

        if is_required || is_tag_name {
            return Some((prop_name.clone(), matched));
        }
    }

    None
}

fn schema_matches_string_value(schema: &Value, input: &str) -> Option<Value> {
    if let Some(const_val) = schema.get("const").and_then(|v| v.as_str()) {
        if normalize_tag(const_val) == normalize_tag(input) {
            return Some(Value::String(const_val.to_string()));
        }
    }

    if let Some(enums) = schema.get("enum").and_then(|v| v.as_array()) {
        for val in enums {
            if let Some(s) = val.as_str() {
                if normalize_tag(s) == normalize_tag(input) {
                    return Some(Value::String(s.to_string()));
                }
            }
        }
    }

    None
}

fn normalize_tag(value: &str) -> String {
    value
        .chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_ascii_lowercase())
        .collect()
}

fn select_variant_for_object<'a>(
    map: &Map<String, Value>,
    variants: &'a [Value],
) -> Option<&'a Value> {
    let keys: Vec<&String> = map.keys().collect();
    variants.iter().find(|variant| {
        variant
            .get("properties")
            .and_then(|p| p.as_object())
            .is_some_and(|props| keys.iter().all(|key| props.contains_key(*key)))
    })
}

fn common_prefix_len(a: &str, b: &str) -> usize {
    a.chars()
        .zip(b.chars())
        .take_while(|(ca, cb)| ca == cb)
        .count()
}

fn levenshtein(a: &str, b: &str) -> usize {
    let a_len = a.len();
    let b_len = b.len();
    if a_len == 0 {
        return b_len;
    }
    if b_len == 0 {
        return a_len;
    }

    let mut prev: Vec<usize> = (0..=b_len).collect();
    let mut curr = vec![0; b_len + 1];

    for (i, ca) in a.chars().enumerate() {
        curr[0] = i + 1;
        for (j, cb) in b.chars().enumerate() {
            let cost = if ca == cb { 0 } else { 1 };
            curr[j + 1] = std::cmp::min(
                std::cmp::min(curr[j] + 1, prev[j + 1] + 1),
                prev[j] + cost,
            );
        }
        prev.clone_from_slice(&curr);
    }

    curr[b_len]
}

/// Convert an OpenAPI-style schema (with nullable: true) to a standard JSON Schema
/// (with type: [T, "null"]) for compatibility with the jsonschema crate.
fn to_standard_json_schema(mut schema: Value) -> Value {
    if let Value::Object(ref mut map) = schema {
        // Handle nullable: true
        if let Some(Value::Bool(true)) = map.remove("nullable") {
            if let Some(type_val) = map.get_mut("type") {
                match type_val {
                    Value::String(s) => {
                        *type_val = serde_json::json!([s, "null"]);
                    }
                    Value::Array(arr) => {
                        let has_null = arr.iter().any(|v| v.as_str() == Some("null"));
                        if !has_null {
                            arr.push(Value::String("null".to_string()));
                        }
                    }
                    _ => {}
                }
            }
        }

        for val in map.values_mut() {
            let taken = std::mem::replace(val, Value::Null);
            *val = to_standard_json_schema(taken);
        }
    } else if let Value::Array(arr) = schema {
        let new_arr = arr.into_iter().map(to_standard_json_schema).collect();
        return Value::Array(new_arr);
    }
    schema
}

#[cfg(test)]
mod tests {
    use super::*;
    use schemars::JsonSchema;
    use serde_json::json;

    #[derive(JsonSchema)]
    struct Contact {
        #[allow(dead_code)]
        phone: Option<String>,
    }

    #[test]
    fn clean_schema_strips_unsupported_keywords() {
        let mut schema = json!({
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "title": "Test",
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "default": "example",
                    "examples": ["a"],
                    "readOnly": true
                }
            },
            "const": "noop"
        });

        clean_schema_for_gemini(&mut schema);

        assert!(schema.get("$schema").is_none());
        assert!(schema.get("title").is_none());
        assert!(schema.get("const").is_none());

        let name_schema = schema
            .get("properties")
            .and_then(|p| p.get("name"))
            .expect("name schema should exist");
        assert!(name_schema.get("default").is_none());
        assert!(name_schema.get("examples").is_none());
        assert!(name_schema.get("readOnly").is_none());
    }

    #[test]
    fn clean_schema_keeps_defs_and_refs() {
        let mut schema = json!({
            "$defs": {
                "Node": {
                    "type": "object",
                    "properties": {
                        "child": { "$ref": "#/$defs/Node" }
                    }
                }
            },
            "$ref": "#/$defs/Node"
        });

        clean_schema_for_gemini(&mut schema);

        assert!(schema.get("$defs").is_some());
        assert!(schema.get("$ref").is_some());
    }

    #[test]
    fn recover_internally_tagged_enum_from_string() {
        let schema = json!({
            "anyOf": [
                {
                    "type": "object",
                    "properties": {"type": {"const": "auto"}},
                    "required": ["type"]
                },
                {
                    "type": "object",
                    "properties": {"type": {"const": "manual"}, "threshold": {"type": "number"}},
                    "required": ["type", "threshold"]
                }
            ]
        });

        let mut value = json!("auto");
        recover_internally_tagged_enums(&mut value, &schema);

        assert_eq!(value, json!({"type": "auto"}));
    }

    #[test]
    fn prune_null_fields_removes_nulls() {
        let mut value = json!({
            "name": "John",
            "age": null,
            "nested": {"field": null, "ok": "yes"}
        });

        prune_null_fields(&mut value);

        assert_eq!(
            value,
            json!({
                "name": "John",
                "nested": {"ok": "yes"}
            })
        );
    }

    #[test]
    fn gemini_schema_builds() {
        let schema = Contact::gemini_schema();
        assert!(schema.get("properties").is_some());
    }
}
